Progress:
1) DONE write tts class and basic methods and unit tests of these
2) DONE write wt class and basic methods and unit tests of these
3) DONE write wmf class and basic methods and unit tests of these 
4) DONE write wpmf class and basic methods and unit tests of these 
4.1) DONE make your error handling functions screen for non-finite values and throw and error
4.2) make the wmpf class have a significance slot, and make accompanying methods deal with it, and add to the unit tests for those methods if necessary, and make the generato function compute significance in a few diff ways (fft, aaft, standard quick way).
  -get surrogate function(s), unit tests for surrogate function - done except for ties aaft case
  -change the generator function
  -change the methods to reflect/impose the new class definition for wpmf
  -unit tests for new aspects of generator
  -unit tests for new aspects of methods
  -go back and use log 2 on the timescales axis in plots in tests_wmf
5) check and unit test cleandat
6) write the plotter functions, and unit tests. perhaps these should go in the methods files? maybe not. think more


wt.r:
#TODO: make this a compiled function using cmpfun in the compiler package
#(which is part of base R)
#TODO: make the truncation occur before the computation rather than after
#TODO: Not clear from the docs what the resulting behavior is for the default
#value NULL of scale.max.input. Likewise for other related funcs (wmf, wpmf, etc)

The arguments of wt, wmf, and wpmf are similar, but the docs describing them
differ sometimes. Why the inconsistency? Revisit all three sets of argument
docs for consistency and accuracy. Likewise for the docs of the outputs.

First line of wpmf:   Why is this called freqs if it is timescales? Possibly confusing.


Ideas I emailed to myself 2018 05 06:
DONE Add data slots to wt wmf
and wpmf classes? So the data can be kept with the result?

Make a ts class which stands for timescale, base class for
coherence results

Then wc swc wpc swpc classes that extend ts. These are for
wavelet coherence,spatial wavelet coherence, wavelet phase
coherence and spatial wavelet phase coherence classes. These
will also have slots for the data, and maybe a slot for the
normalization used? If you are having that slot, you may not
need all these classes. If you are also having the data you may
need only one class

ts has slots for timescale and for a complex vector of the same
length

These classes (except ts) also have slots for coherences of
surrogates, and maybe for post-ranking results.

Have a wcoh and pcoh classes for wavelet and phase coherence.
Since data are included as slot(s) we do not need to specify
spatial or not.

Also have a gcoh class for general coherence. This is for
alternative normalizations. You have to pass in some kind of
normalization routine. Available alternatives include no
normalization and normalizing each time series separately by
power. The normalization function is included in the object
