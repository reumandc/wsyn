Progress:
1) DONE write tts class and basic methods and unit tests of these
2) DONE write wt class and basic methods and unit tests of these
3) DONE write wmf class and basic methods and unit tests of these 
4) DONE write wpmf class and basic methods and unit tests of these 
4.1) DONE make your error handling functions screen for non-finite values and throw an error
4.2) DONE make the wmpf class have a significance slot, and make accompanying methods deal with it, and add to the unit tests for those methods if necessary, and make the generato function compute significance in a few diff ways (fft, aaft, standard quick way).
  -DONE get surrogate function(s), unit tests for surrogate function 
  -DONE change the generator function
  -DONE change the methods to reflect/impose the new class definition for wpmf
  -DONE unit tests for new aspects of generator
  -DONE unit tests for new aspects of methods
  -DONE go back and use log 2 on the timescales axis in plots in tests_wmf
5) DONE check and unit test cleandat
6) DONE write the magnitude plotter functions, and unit tests. perhaps these should go in the methods files? maybe not. think more
6.5) DONE Go back and add joint Box-Cox to cleandat, and unit tests
6.75) DONE get the .Rmds going and compile everything as a package
8) start a vignette, covering the code you have written so far - done except for surrogates, have to do that section, but leaving that until after coherence stuff is written
9) compile again as a package
10) stopping point - mean field methods implemented. next step coherence methods.
11) Work on coherence functionality, inc unit tests and vignette and making the package compile. Need to start with a design phase and working out appropriate S3 classes. See some thoughts below.
12) everything you need for deer
13) synmat for kelp and Jon's bird stuff
14) write the phase plotter functions, and unit tests. Consolidate into one plotphase.R file, as you did for the magnitude plotters.
15) print and summary methods for all the classes


for formatting the documentation at top:
1) use \code{} for TRUE and FALSE. Do not use T and F.
2) I foudn and deleted a comment in the header of wmpf to the effect that "the wavelet phasor mean field was developed by Sheppard and Reuman, R code written by Anderson and Walter." It was not developed by Shppard and Reuman, and now the R code is by all of us, so I changed it. Watch out for other notes like that, I think I remember seeing some more.

general
1) It will be possible to be a bit more consistent with use of get and set methods instead of $
2) DONE you need an error checking function for scale.min, scale.max, f0, sigma, and you need to call it from the top of all functions that take these as arguments. Also
indicate in vignette and in help files what the constraints are. 
3) DONE times can ONLY be spaced with units of one, otherwise the code does not
work as it is. This is a fundamental problem and would require changes in lots of 
places if we wanted to add the flexibility of times spaced other than 1. So just add this requirement to your error checking. Also in docs and vignette. Everything is in 
cycles per sample - Lawrence assumes this in his matlab code. 
4) do a test case with Lawrence for non-integer scale.min. For that matter do some
testing with non dedault values of all of scale.min, scale.max, f0, sigma. One thing to test is, if you use scale.max.input very large, then scallopping should produce
the actual largest timescale and this should be the same for even larger scale.max.input. I said this was the case in the vignette (toward the end of the wt section), so if it turns out not to be the case, go back and change that part of the vignette
5) DONE Add a paragraph to the vignette explaining what scale.min, scale.max, f0, sigma,
or ask Lawrence to do it. 
6) DONE test coh with vectors, also with 1 by N matrices
7) right now, when using the fast method, coh only really works with powall normalization, for powind or none, it could be made to work, but right now it will
do powall normalization on the components of signif and powing or none on coher

wt.r:
#TODO: make this a compiled function using cmpfun in the compiler package
#(which is part of base R)
#TODO: make the truncation occur before the computation rather than after
#TODO: Not clear from the docs what the resulting behavior is for the default
#value NULL of scale.max.input. Likewise for other related funcs (wmf, wpmf, etc)


Ideas I emailed to myself 2018 05 06:
DONE Add data slots to wt wmf and wpmf classes? So the data can be kept with the result?

Make a ts class which stands for timescale, base class for
coherence results

Then wc swc wpc swpc classes that extend ts. These are for
wavelet coherence,spatial wavelet coherence, wavelet phase
coherence and spatial wavelet phase coherence classes. These
will also have slots for the data, and maybe a slot for the
normalization used? If you are having that slot, you may not
need all these classes. If you are also having the data you may
need only one class

ts has slots for timescale and for a complex vector of the same
length

These classes (except ts) also have slots for coherences of
surrogates, and maybe for post-ranking results.

Have a wcoh and pcoh classes for wavelet and phase coherence.
Since data are included as slot(s) we do not need to specify
spatial or not.

Also have a gcoh class for general coherence. This is for
alternative normalizations. You have to pass in some kind of
normalization routine. Available alternatives include no
normalization and normalizing each time series separately by
power. The normalization function is included in the object
____

ts has slots for timescale and for a complex vector of the same
length - might not be necessary if I only have one coherence class. Decided to abandon it.

coh class (coh for coherence)
slots: 
dat1, dat2 - the data, stored 
times - times of measurement
norm - the normalization used in computing the coherence (one of "phase", "none", "powall" (this 
one is the normalization we used in the wavelet coherence in the aphid paper), 
and "powind" (this one is the normalization Lawrence mentioned by the power
of each time series individually, check this last with Lawrence when you code it))
timescales - vector of timescales
coh - the coherence, calculated in the usual way without scalloping, after 
normalization as specified by "norm"  
signif - a list with elements coh (the coherence of dat1 and dat2for significance testing, 
equal to  coh except in the "fast" case) and scoh (a matrix with all the 
surrogate coherences, for comparison with signif$coh)
bandp - stores p-values across timescale bands that have been computed. it's a data frame, 
empty on first call to the generator function for the coh class

coh function, the generator of the class, has these arguments:
dat1 - either a locations by times matrix or a vector
dat2 - same as dat1 - they must be the same dimensions
times - times of measurement
norm - see above
sigmethod - method for significance testing, one of "none", "surrog1", "surrog2", "surrog12", "fast"
nrand - number of randomizations for significance testing
all the parameters for the wavelet transform, e.g., f0, scale.min, etc.

When you run coh, the bandp slot is NA at first until you run the last of the below functions

Methods:
set (which throw an error) and get methods for changing and extracting the slot entries
print and summary methods
something for plotting coherence against timescale - if bandp is not NA, puts the p-values on the plot. Call it plot.
something for plotting ranks in surrogates against timescale - if bandp is not NA, puts the p-values on the plot. Also call it plot. Whether this or the previous or both are generated is controlled by a switch argument.
something for p-values across timescale bands - populates bandp or adds to it. Call it cohbandsignif